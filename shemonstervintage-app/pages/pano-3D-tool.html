<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<title>Pano + Grid-Scan · 0.25m Cube · Minimap Drag · Kamera GUI (Yaw/Pitch/FOV)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  html,body { height:100%; margin:0; background:#0b0b0b; overflow:hidden; }
  #ui { position:fixed; top:10px; left:10px; z-index:1000; display:flex; gap:.5rem; align-items:center; }
  .btn {
    --bg1:#1a2740; --bg2:#0f172a; --border:#2b3b6b; --hover:#243b74; --active:#162452;
    color:#e6ebff; font:600 13px/1 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    padding:.6rem .9rem; border-radius:10px; border:1px solid var(--border);
    background: linear-gradient(180deg, var(--bg1), var(--bg2));
    box-shadow: 0 4px 12px rgba(0,0,0,.25), inset 0 1px 0 rgba(255,255,255,.05);
    cursor:pointer; transition: all .15s ease;
  }
  .btn:hover { background: linear-gradient(180deg, var(--hover), var(--bg2)); transform: translateY(-1px); }
  .btn:active { background: linear-gradient(180deg, var(--active), var(--bg2)); transform: translateY(0); }
  canvas { display:block; }
  #minimap {
    position: fixed; left: 10px; bottom: 10px; z-index: 10000;
    width: 220px; height: 220px;
    border: 1px solid #2a2a2a; border-radius: 8px; background: #0e0e10;
    box-shadow: 0 6px 18px rgba(0,0,0,.35);
    cursor: crosshair;
  }
  #minimap.dragging { cursor: grabbing; }
  .lil-gui .folder.active-cube > .title {
    background: linear-gradient(90deg, #244cff, #0f1a3a) !important;
    color: #fff !important;
    text-shadow: 0 1px 0 rgba(0,0,0,.25);
  }
  .lil-gui .folder.active-cube { box-shadow: 0 0 0 2px #244cff inset; border-radius: 6px; }
  .lil-gui.autoPlace { top: 0; right: 0; }
</style>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
  }
}
</script>
</head>
<body>
  <div id="ui">
    <input id="file" type="file" accept="image/*" />
    <button id="spawn" class="btn">＋ New Cube</button>
    <button id="resetView" class="btn">↺ Reset Position</button>
  </div>
  <canvas id="minimap" width="440" height="440"></canvas>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { GUI } from 'https://unpkg.com/lil-gui@0.19/dist/lil-gui.esm.js';

import { LineSegmentsGeometry } from 'three/addons/lines/LineSegmentsGeometry.js';
import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
import { LineSegments2 } from 'three/addons/lines/LineSegments2.js';

/* ---------- Renderer & Kamera ---------- */
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);
renderer.domElement.setAttribute('tabindex','0');
renderer.domElement.addEventListener('click', ()=> renderer.domElement.focus());

const CAMERA_RADIUS = 1e-4;
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.001, 1000);
camera.position.set(0,0,CAMERA_RADIUS);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enablePan = false;
controls.enableZoom = false; // FOV via Wheel
controls.enableDamping = true;
controls.dampingFactor = 0.07;
controls.rotateSpeed = 0.9;
controls.target.set(0,0,0);
controls.saveState();

/* ---------- Szene / Grid ---------- */
const sceneObjects = new THREE.Scene();
sceneObjects.add(new THREE.HemisphereLight(0xffffff, 0x222233, 1.0));
const dl = new THREE.DirectionalLight(0xffffff, 0.7); dl.position.set(1,1,1); sceneObjects.add(dl);

const SPHERE_RADIUS = 2.0;
const DEFAULT_SIZE = 0.25; // 25 cm
const CUBE_RANGE = 5.0;

const gridGeom = new THREE.PlaneGeometry(200, 200, 1, 1);
gridGeom.rotateX(-Math.PI/2);
const gridMat = new THREE.ShaderMaterial({
  transparent: true, depthWrite: false,
  uniforms: {
    color: { value: new THREE.Color(0x00ffcc) },
    spacing: { value: 0.1 },
    thickness:{ value: 0.015 },
    clipToSphere:{ value: true },
    sphereRadius:{ value: SPHERE_RADIUS },
    planeY: { value: 0.0 },
    ringColor: { value: new THREE.Color(0x4ea1ff) },
    ringOpacity: { value: 1.0 },
    axisColor:   { value: new THREE.Color(0xffe28a) },
    axisAlpha:   { value: 1.0 },
    axisThickness:{ value: 1.5 }
  },
  vertexShader: `varying vec3 vWorldPos; void main(){ vec4 wp=modelMatrix*vec4(position,1.0); vWorldPos=wp.xyz; gl_Position=projectionMatrix*viewMatrix*wp; }`,
  fragmentShader: `
    precision highp float; varying vec3 vWorldPos;
    uniform vec3 color, ringColor, axisColor; uniform float spacing, thickness, sphereRadius, planeY, ringOpacity, axisAlpha, axisThickness; uniform bool clipToSphere;
    float gridMask(vec2 p, float s, float t){ vec2 c=p/s; vec2 fw=max(fwidth(c), vec2(1e-6)); vec2 g=abs(fract(c)-0.5)/fw; float line=1.0-min(min(g.x,g.y)*(t*50.0),1.0); return line; }
    void main(){
      float h=planeY; float rEff2=max(sphereRadius*sphereRadius-h*h,0.0); float rEff=sqrt(rEff2);
      float r=length(vWorldPos.xz); if(clipToSphere && r>rEff+1e-4) discard;
      float m=gridMask(vWorldPos.xz, spacing, thickness);
      float fade=1.0; if(clipToSphere){ float d=clamp((rEff-r)/0.2,0.0,1.0); fade=d; }
      float w=fwidth(r)*1.5; float ring=1.0-smoothstep(w,w*2.0,abs(r-rEff));
      float fx=fwidth(vWorldPos.x), fz=fwidth(vWorldPos.z);
      float halfW_x=max(axisThickness*fx,1e-6), halfW_z=max(axisThickness*fz,1e-6);
      float lineX=1.0-smoothstep(0.0,halfW_x,abs(vWorldPos.x));
      float lineZ=1.0-smoothstep(0.0,halfW_z,abs(vWorldPos.z));
      float axisMask=max(lineX,lineZ);
      vec3 finalCol=color; float finalAlpha=m*0.85*fade;
      finalCol=mix(finalCol, ringColor, clamp(ring*ringOpacity,0.0,1.0)); finalAlpha=max(finalAlpha, ring*ringOpacity);
      finalCol=mix(finalCol, axisColor, clamp(axisMask*axisAlpha,0.0,1.0)); finalAlpha=max(finalAlpha, axisMask*axisAlpha);
      if(finalAlpha<=0.0) discard; gl_FragColor=vec4(finalCol, finalAlpha);
    }`
});
const gridMesh = new THREE.Mesh(gridGeom, gridMat);
sceneObjects.add(gridMesh);

/* Grid global konfigurieren */
gridMat.depthTest = true;
gridMat.depthWrite = false;
gridMesh.renderOrder = 9999;

/* ---------- Pano + Post Pass ---------- */
const db = new THREE.Vector2(); renderer.getDrawingBufferSize(db);
let rtObjects  = new THREE.WebGLRenderTarget(db.x, db.y, { depthBuffer:true });
let rtCombined = new THREE.WebGLRenderTarget(db.x, db.y, { depthBuffer:false });

let panoTex = new THREE.Texture();
panoTex.colorSpace = THREE.SRGBColorSpace;
panoTex.wrapS = THREE.RepeatWrapping; panoTex.wrapT = THREE.ClampToEdgeWrapping;

const fsCam = new THREE.OrthographicCamera(-1,1,1,-1,0,1);
const screenSceneA = new THREE.Scene();
const screenSceneB = new THREE.Scene();

const passAMat = new THREE.ShaderMaterial({
  uniforms:{
    objTex:{ value: rtObjects.texture },
    pano:{ value: panoTex },
    resolution:{ value: db.clone() },
    fovY:{ value: THREE.MathUtils.degToRad(camera.fov) },
    aspect:{ value: camera.aspect },
    camBasis:{ value: new THREE.Matrix3() },
    rotXYZ:{ value: new THREE.Vector3(0,0,0) }
  },
  vertexShader: `varying vec2 vUv; void main(){ vUv=position.xy*0.5+0.5; gl_Position=vec4(position.xy,0.0,1.0); }`,
  fragmentShader: `
    precision highp float; uniform sampler2D objTex, pano; uniform vec2 resolution; uniform float fovY, aspect; uniform mat3 camBasis; uniform vec3 rotXYZ;
    const float PI=3.141592653589793;
    vec3 rayFromNDC(vec2 ndc){ float t=tan(0.5*fovY); vec3 dCam=normalize(vec3(ndc.x*aspect*t, ndc.y*t, -1.0)); return normalize(camBasis*dCam); }
    vec3 applyEulerXYZ(vec3 v, vec3 r){ float cx=cos(r.x), sx=sin(r.x), cy=cos(r.y), sy=sin(r.y), cz=cos(r.z), sz=sin(r.z);
      v=vec3(v.x, cx*v.y - sx*v.z, sx*v.y + cx*v.z); v=vec3(cy*v.x + sy*v.z, v.y, -sy*v.x + cy*v.z); v=vec3(cz*v.x - sz*v.y, sz*v.x + cz*v.y, v.z); return v; }
    vec3 samplePano(vec3 dir, vec3 rot){ dir=normalize(applyEulerXYZ(dir,rot));
      float u=fract(atan(dir.z,dir.x)/(2.0*PI)+0.5); float v=clamp(asin(clamp(dir.y,-1.0,1.0))/PI+0.5,0.0,1.0);
      return texture2D(pano, vec2(u,v)).rgb; }
    void main(){
      vec2 ndc=(gl_FragCoord.xy/resolution)*2.0-1.0; vec3 dir=rayFromNDC(ndc);
      vec3 panoCol=samplePano(dir,rotXYZ); vec2 uvRect=ndc*0.5+0.5; vec4 objCol=vec4(0.0);
      if(all(greaterThanEqual(uvRect,vec2(0.0)))&&all(lessThanEqual(uvRect,vec2(1.0)))) objCol=texture2D(objTex,uvRect);
      gl_FragColor=vec4(mix(panoCol,objCol.rgb,objCol.a),1.0);
    }`,
  depthTest:false, depthWrite:false
});
screenSceneA.add(new THREE.Mesh(new THREE.PlaneGeometry(2,2), passAMat));

const passBMat = new THREE.ShaderMaterial({
  uniforms:{ src:{value: rtCombined.texture}, resolution:{value: db.clone()}, k1:{value: -0.25}, k2:{value: 0.0} },
  vertexShader:`varying vec2 vUv; void main(){ vUv=position.xy*0.5+0.5; gl_Position=vec4(position.xy,0.0,1.0); }`,
  fragmentShader:`precision highp float; varying vec2 vUv; uniform sampler2D src; uniform vec2 resolution; uniform float k1,k2;
    void main(){ vec2 c=vec2(0.5); vec2 xy=vUv-c; float a=resolution.x/max(resolution.y,1.0);
      xy.x*=a; float r2=dot(xy,xy); float f=1.0+k1*r2+k2*r2*r2; vec2 w=xy*f; w.x/=a;
      vec2 uv=c+w; if(any(lessThan(uv,vec2(0.0)))||any(greaterThan(uv,vec2(1.0)))) gl_FragColor=vec4(0.0);
      else gl_FragColor=texture2D(src,uv); }`,
  depthTest:false, depthWrite:false
});
screenSceneB.add(new THREE.Mesh(new THREE.PlaneGeometry(2,2), passBMat));

/* ---------- GUI ---------- */
const gui = new GUI({ title: 'Pano Settings' });
const params = {
  rotX_deg: 0, rotY_deg: 0, rotZ_deg: 0,
  k1: -0.25, k2: 0.0,
  cameraFov: camera.fov,
  gridHeight: 0.0, gridClip: true, gridVisible: true,
  gridSpacing: 0.10,
  activeId: -1
};
let lastGridY = 0.0;

const updateRot = ()=>{
  passAMat.uniforms.rotXYZ.value.set(
    THREE.MathUtils.degToRad(params.rotX_deg),
    THREE.MathUtils.degToRad(params.rotY_deg),
    THREE.MathUtils.degToRad(params.rotZ_deg)
  );
};
gui.add(params,'rotX_deg',-180,180,0.1).name('Textur Rot X°').onChange(updateRot);
gui.add(params,'rotY_deg',-180,180,0.1).name('Textur Rot Y°').onChange(updateRot);
gui.add(params,'rotZ_deg',-180,180,0.1).name('Textur Rot Z°').onChange(updateRot);
gui.add(params,'k1',-0.6,0.6,0.005).name('De-Fisheye k1').onChange(v=> passBMat.uniforms.k1.value = v);
gui.add(params,'k2',-0.6,0.6,0.005).name('Fein k2').onChange(v=> passBMat.uniforms.k2.value = v);

const cameraFovCtrl = gui.add(params,'cameraFov',40,140,0.1).name('Kamera FOV')
  .onChange(v=>{ camera.fov=v; camera.updateProjectionMatrix(); passAMat.uniforms.fovY.value=THREE.MathUtils.degToRad(v); });

/* ---------- Grid Settings (zusammengeführt) ---------- */
const gridSettings = gui.addFolder('Grid Settings');
gridSettings.add(params,'gridVisible').name('Grid sichtbar').onChange(v=> gridMesh.visible = v);
gridSettings.add(gridMat.uniforms.spacing,'value',0.01,1.00,0.01).name('Feldgröße [m]');
gridSettings.addColor({axis:'#ffe28a'},'axis').name('Achsenfarbe')
  .onChange(v => gridMat.uniforms.axisColor.value.set(v));
gridSettings.add(gridMat.uniforms.axisThickness,'value',0.5,3.0,0.1).name('Achsendicke [px]');

/* --- Helper: Grid-Höhe zentral setzen --- */
function setGridY(v){
  v = THREE.MathUtils.clamp(v, -5, 5);
  const dy = v - lastGridY;
  gridMesh.position.y = v;
  gridMat.uniforms.planeY.value = v;
  cubes.forEach(c=>{
    c.mesh.position.y += dy;           // Abstand zum Grid beibehalten
    updateRaysFor(c.mesh, c.rays, c.sizes);
    c.syncFromMesh();
  });
  lastGridY = v;
  params.gridHeight = v;
  gridHeightCtrl.updateDisplay();
}
const gridHeightCtrl = gridSettings.add(params,'gridHeight',-5,5,0.01).name('Grid Höhe (Y)')
  .onChange(setGridY);

updateRot();

/* ---------- Kamera · Position (Yaw/Pitch/FOV) ---------- */
const camInfo = { yaw:0, pitch:0, fov:camera.fov };
const infoFolder = gui.addFolder('Kamera · Position');

const yawCtrl   = infoFolder.add(camInfo,'yaw',  -180,180,0.1).name('Yaw [°]').listen()
  .onChange(()=> applyCameraFromGUI());
const pitchCtrl = infoFolder.add(camInfo,'pitch', -89, 89,0.1).name('Pitch [°]').listen()
  .onChange(()=> applyCameraFromGUI());
const fovCtrl   = infoFolder.add(camInfo,'fov',   40,140,0.1).name('FOV [°]').listen()
  .onChange(v=>{
    camera.fov = v; camera.updateProjectionMatrix();
    passAMat.uniforms.fovY.value = THREE.MathUtils.degToRad(v);
    params.cameraFov = v;
  });

function applyCameraFromGUI(){
  const yaw = THREE.MathUtils.degToRad(camInfo.yaw);
  const pitch = THREE.MathUtils.degToRad(camInfo.pitch);
  const q = new THREE.Euler(pitch, yaw, 0, 'YXZ');
  camera.quaternion.setFromEuler(q);
  camera.updateMatrixWorld(true);

  const fwd = new THREE.Vector3();
  camera.getWorldDirection(fwd);
  camera.position.copy(controls.target).sub(fwd.multiplyScalar(CAMERA_RADIUS));

  camera.updateMatrixWorld(true);
  controls.update();
}
function syncCamInfoFromCamera(){
  const e = new THREE.Euler().setFromQuaternion(camera.quaternion,'YXZ');
  camInfo.yaw   = +(THREE.MathUtils.radToDeg(e.y)).toFixed(2);
  camInfo.pitch = +(THREE.MathUtils.radToDeg(e.x)).toFixed(2);
  camInfo.fov   = +camera.fov.toFixed(2);
  [yawCtrl,pitchCtrl,fovCtrl].forEach(c=> c.updateDisplay());
}

/* ---------- Würfel / Picking ---------- */
const cubesFolder = gui.addFolder('Würfel');
const cubes = []; // { id, mesh, edges, rays, gui, state, sizes, ... }
const pickables = [];
let nextCubeId = 1;

function makeRayGroup(color=0x00ff00){
  const g = new THREE.Group();
  const mat = new THREE.LineBasicMaterial({ color, transparent:true, opacity:0.95 });

  for(let i=0;i<6;i++){
    const geo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]);
    const line = new THREE.Line(geo, mat.clone());
    line.material.depthWrite = false;
    g.add(line);
  }
  g.renderOrder = 10000;
  return g;
}
function updateRaysFor(mesh, rays, sizes){
  const localNormals=[ new THREE.Vector3(1,0,0),new THREE.Vector3(-1,0,0),
                       new THREE.Vector3(0,1,0),new THREE.Vector3(0,-1,0),
                       new THREE.Vector3(0,0,1),new THREE.Vector3(0,0,-1) ];
  const half={ x:sizes.x*0.5, y:sizes.y*0.5, z:sizes.z*0.5 };
  const pos=mesh.position.clone(); const q=mesh.quaternion.clone();
  for(let i=0;i<6;i++){
    const ln=localNormals[i]; const worldNormal=ln.clone().applyQuaternion(q).normalize();
    const offsetLocal=new THREE.Vector3(
      ln.x!==0?Math.sign(ln.x)*half.x:0,
      ln.y!==0?Math.sign(ln.y)*half.y:0,
      ln.z!==0?Math.sign(ln.z)*half.z:0
    );
    const offsetWorld=offsetLocal.clone().applyQuaternion(q);
    const faceCenter=pos.clone().add(offsetWorld);
    const b=2.0*faceCenter.dot(worldNormal); const c=faceCenter.lengthSq()-SPHERE_RADIUS*SPHERE_RADIUS;
    const disc=b*b-4.0*c; let t=0.0;
    if(disc>=0.0){ const sqrtD=Math.sqrt(disc); const t1=(-b+sqrtD)*0.5; const t2=(-b-sqrtD)*0.5; t=Math.max(t1,t2); if(t<0.0) t=0.0; }
    const end=faceCenter.clone().addScaledVector(worldNormal,t);
    const line=rays.children[i];
    const arr=new Float32Array([faceCenter.x,faceCenter.y,faceCenter.z,end.x,end.y,end.z]);
    line.geometry.setAttribute('position', new THREE.BufferAttribute(arr,3));
    line.geometry.computeBoundingSphere();
  }
}

function isGuiInputFocused(){
  const a=document.activeElement;
  return !!(a && (a.tagName==='INPUT'||a.tagName==='SELECT'||a.tagName==='TEXTAREA') && a.closest('.lil-gui'));
}
const snap001 = v => { const s=Math.round(v/0.01)*0.01; return Math.abs(s)<1e-9?0:+s.toFixed(6); };

function activateCubeById(id){
  params.activeId=id;
  cubes.forEach(c=>{
    const isActive=c.id===id;
    c.gui.domElement.classList.toggle('active-cube', isActive);
    if(c.rays) c.rays.visible=isActive;
    const mat=c.mesh.material;
    if (mat && 'emissive' in mat) {
      mat.emissive.setHex(0x6690ff);
      mat.emissiveIntensity=isActive?0.30:0.18;
      mat.needsUpdate=true;
    }
  });
  if(id!==-1) renderer.domElement.focus();
}

/* ---------- Outline (1.5 px, DPR-sicher) ---------- */
function buildCrispEdges(mesh, colorHex){
  const edgesGeo = new THREE.EdgesGeometry(mesh.geometry, 1);
  const segGeo = new LineSegmentsGeometry().fromEdgesGeometry(edgesGeo);
  edgesGeo.dispose();

  const mat = new LineMaterial({
    color: colorHex,
    worldUnits: false,
    dashed: false,
    depthTest: true,
    depthWrite: false,
    transparent: false,
    opacity: 1.0
  });

  const dbSize = new THREE.Vector2();
  renderer.getDrawingBufferSize(dbSize);
  mat.resolution.set(dbSize.x, dbSize.y);
  mat.linewidth = 1.5;
  mat.needsUpdate = true;

  const lines = new LineSegments2(segGeo, mat);
  lines.renderOrder = 10;
  mesh.add(lines);
  return lines;
}

/* ---------- Spawn ---------- */
function spawnCube(){
  const id = nextCubeId++;

  const mat = new THREE.MeshStandardMaterial({
    color: 0x5a7dff,
    roughness: 0.4,
    metalness: 0.08,
    emissive: 0x6690ff,
    emissiveIntensity: 0.18,
    transparent: false,
    opacity: 1.0,
    depthWrite: true,
    polygonOffset: true,
    polygonOffsetFactor: 2,
    polygonOffsetUnits: 2
  });

  const geom = new THREE.BoxGeometry(DEFAULT_SIZE, DEFAULT_SIZE, DEFAULT_SIZE);
  const mesh = new THREE.Mesh(geom, mat);

  const sizes = { x: DEFAULT_SIZE, y: DEFAULT_SIZE, z: DEFAULT_SIZE };
  const gy = gridMesh.position.y;
  mesh.position.set(0, gy + sizes.y*0.5, 0);
  mesh.rotation.set(0,0,0);
  mesh.scale.set(1,1,1);

  const edges = buildCrispEdges(mesh, mat.color.getHex());

  sceneObjects.add(mesh);
  pickables.push(mesh);

  const rays = makeRayGroup(0x00ff00);
  sceneObjects.add(rays);

  const f = cubesFolder.addFolder(`Würfel ${cubes.length+1}`);
  const state = {
    x: mesh.position.x, y: mesh.position.y, z: mesh.position.z,
    rx: 0, ry: 0, rz: 0,
    sizeX: sizes.x, sizeY: sizes.y, sizeZ: sizes.z,
    color: '#5a7dff',
    opacity: 1.0
  };
  const toDeg = r => THREE.MathUtils.radToDeg(r);
  const toRad = d => THREE.MathUtils.degToRad(d);

  const posX = f.add(state,'x', -CUBE_RANGE, CUBE_RANGE, 0.01).name('Pos X [m]')
    .onChange(v=>{ mesh.position.x = snap001(+v); updateRaysFor(mesh, rays, sizes); });
  const posY = f.add(state,'y', -CUBE_RANGE, CUBE_RANGE, 0.01).name('Pos Y [m]')
    .onChange(v=>{ mesh.position.y = snap001(+v); updateRaysFor(mesh, rays, sizes); });
  const posZ = f.add(state,'z', -CUBE_RANGE, CUBE_RANGE, 0.01).name('Pos Z [m]')
    .onChange(v=>{ mesh.position.z = snap001(+v); updateRaysFor(mesh, rays, sizes); });

  const rotX = f.add(state,'rx', -180, 180, 0.1).name('Rot X [°]').onChange(v=>{ mesh.rotation.x = toRad(v); updateRaysFor(mesh, rays, sizes); });
  const rotY = f.add(state,'ry', -180, 180, 0.1).name('Rot Y [°]').onChange(v=>{ mesh.rotation.y = toRad(v); updateRaysFor(mesh, rays, sizes); });
  const rotZ = f.add(state,'rz', -180, 180, 0.1).name('Rot Z [°]').onChange(v=>{ mesh.rotation.z = toRad(v); updateRaysFor(mesh, rays, sizes); });

  const sizeXCtrl = f.add(state,'sizeX', 0.05, 5.0, 0.01).name('Größe X [m]').onChange(v=>{
    sizes.x = Math.max(0.01, +v);
    mesh.scale.x = sizes.x / DEFAULT_SIZE;
    updateRaysFor(mesh, rays, sizes);
  });
  const sizeYCtrl = f.add(state,'sizeY', 0.05, 5.0, 0.01).name('Größe Y [m]').onChange(v=>{
    const centerAboveGrid = mesh.position.y - gridMesh.position.y - sizes.y*0.5;
    sizes.y = Math.max(0.01, +v);
    mesh.scale.y = sizes.y / DEFAULT_SIZE;
    mesh.position.y = gridMesh.position.y + sizes.y*0.5 + centerAboveGrid;
    updateRaysFor(mesh, rays, sizes);
    syncFromMesh();
  });
  const sizeZCtrl = f.add(state,'sizeZ', 0.05, 5.0, 0.01).name('Größe Z [m]').onChange(v=>{
    sizes.z = Math.max(0.01, +v);
    mesh.scale.z = sizes.z / DEFAULT_SIZE;
    updateRaysFor(mesh, rays, sizes);
  });

  const colorCtrl = f.addColor(state,'color').name('Farbe')
    .onChange(v=>{
      mesh.material.color.set(v);
      if (edges?.material) edges.material.color.set(v);
    });

  const opacityCtrl = f.add(state,'opacity', 0.0, 1.0, 0.01).name('Transparenz')
    .onChange(v=>{
      const val = Math.max(0, Math.min(1, +v));
      mesh.material.opacity = val;
      mesh.material.transparent = val < 1.0;
      mesh.material.depthWrite = true;
      mesh.material.needsUpdate = true;
    });

  f.add({Entfernen:()=>{
    const idx = cubes.findIndex(cc => cc.id === id);
    f.destroy();
    if(rays){ rays.traverse(o=>{ if(o.geometry) o.geometry.dispose?.(); }); sceneObjects.remove(rays); }
    if(mesh){
      if (edges){ edges.geometry.dispose?.(); edges.material.dispose?.(); }
      mesh.geometry.dispose?.(); mesh.material.dispose?.();
      sceneObjects.remove(mesh);
      const pi = pickables.indexOf(mesh); if (pi>=0) pickables.splice(pi,1);
    }
    if(idx>=0) cubes.splice(idx,1);
    cubes.forEach((c, i)=> c.gui.title(`Würfel ${i+1}`));
    if (params.activeId === id){
      if (cubes.length) activateCubeById(cubes[Math.min(idx, cubes.length-1)].id);
      else activateCubeById(-1);
    } else {
      const still = cubes.some(c=> c.id === params.activeId);
      activateCubeById(still ? params.activeId : -1);
    }
  }}, 'Entfernen').name('✖ Entfernen');

  function syncFromMesh(){
    state.x = snap001(mesh.position.x);
    state.y = snap001(mesh.position.y);
    state.z = snap001(mesh.position.z);
    state.rx = +toDeg(mesh.rotation.x).toFixed(1);
    state.ry = +toDeg(mesh.rotation.y).toFixed(1);
    state.rz = +toDeg(mesh.rotation.z).toFixed(1);
    state.sizeX = sizes.x; state.sizeY = sizes.y; state.sizeZ = sizes.z;
    state.opacity = +mesh.material.opacity.toFixed(2);
    [posX,posY,posZ,rotX,rotY,rotZ,sizeXCtrl,sizeYCtrl,sizeZCtrl,colorCtrl,opacityCtrl].forEach(c=> c.updateDisplay());
  }

  const record = {
    id, mesh, edges, rays, gui:f, state,
    sizes,
    inputControllers: [posX,posY,posZ,rotX,rotY,rotZ,sizeXCtrl,sizeYCtrl,sizeZCtrl,colorCtrl,opacityCtrl],
    syncFromMesh,
    sizeXCtrl, sizeYCtrl, sizeZCtrl, opacityCtrl
  };
  cubes.push(record);

  syncFromMesh();
  updateRaysFor(mesh, rays, sizes);
  activateCubeById(id);
  renderer.domElement.focus();
}

/* ---------- Picking ---------- */
const raycaster = new THREE.Raycaster();
const mouseNDC = new THREE.Vector2();
function pickAtClient(x, y){
  const rect = renderer.domElement.getBoundingClientRect();
  const mx = ((x - rect.left) / rect.width) * 2 - 1;
  const my = -((y - rect.top) / rect.height) * 2 + 1;
  mouseNDC.set(mx, my);
  raycaster.setFromCamera(mouseNDC, camera);
  const hits = raycaster.intersectObjects(pickables, false);
  if (hits.length){
    const obj = hits[0].object;
    const rec = cubes.find(c=> c.mesh === obj);
    if (rec){
      activateCubeById(rec.id);
      updateRaysFor(rec.mesh, rec.rays, rec.sizes);
      return;
    }
  }
  activateCubeById(-1);
}
renderer.domElement.addEventListener('pointerdown', (ev)=>{
  if (ev.button !== 0) return;
  const guiRect = document.querySelector('.lil-gui')?.getBoundingClientRect();
  if (guiRect && ev.clientX >= guiRect.left && ev.clientX <= guiRect.right &&
      ev.clientY >= guiRect.top  && ev.clientY <= guiRect.bottom){
    return;
  }
  pickAtClient(ev.clientX, ev.clientY);
});

/* ---------- Tastatur Move: 0.01 m Schritte ---------- */
function isGuiInputFocusedShort(){
  const a = document.activeElement;
  return a && (a.tagName === 'INPUT' || a.tagName === 'SELECT' || a.tagName === 'TEXTAREA') && a.closest('.lil-gui');
}
window.addEventListener('keydown', (e)=>{
  if (isGuiInputFocusedShort()) return;
  const rec = cubes.find(c=> c.id === params.activeId);
  if(!rec) return;

  if (['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','PageUp','PageDown'].includes(e.code) || e.key==='+' || e.key==='#') {
    e.preventDefault();
  }

  const step = 0.01;
  let moved = false;

  if(e.code === 'ArrowUp')    { rec.mesh.position.z = snap001(rec.mesh.position.z - step); moved = true; }
  if(e.code === 'ArrowDown')  { rec.mesh.position.z = snap001(rec.mesh.position.z + step); moved = true; }
  if(e.code === 'ArrowLeft')  { rec.mesh.position.x = snap001(rec.mesh.position.x - step); moved = true; }
  if(e.code === 'ArrowRight') { rec.mesh.position.x = snap001(rec.mesh.position.x + step); moved = true; }
  if(e.key === '+' || e.code === 'NumpadAdd' || e.code === 'PageUp'){ rec.mesh.position.y = snap001(rec.mesh.position.y + step); moved = true; }
  if(e.key === '#' || e.code === 'PageDown'){ rec.mesh.position.y = snap001(rec.mesh.position.y - step); moved = true; }

  if(moved){
    updateRaysFor(rec.mesh, rec.rays, rec.sizes);
    rec.syncFromMesh();
  }
});

/* ---------- Minimap (korrekte Skalierung) ---------- */
const mini = document.getElementById('minimap');
const mctx = mini.getContext('2d');

function getMiniTransform(){
  const W = mini.width, H = mini.height;
  const marginPx = 10;
  const pxPerMeter = (Math.min(W, H) * 0.5 - marginPx) / SPHERE_RADIUS;
  const cx = W * 0.5, cy = H * 0.5;
  return { W, H, cx, cy, pxPerMeter, marginPx };
}

function worldXZToMini(x, z){
  const { pxPerMeter, cx, cy } = getMiniTransform();
  return { x: x*pxPerMeter + cx, y: z*pxPerMeter + cy };
}

function miniToWorldXZ(clientX, clientY){
  const { pxPerMeter, cx, cy } = getMiniTransform();
  const r = mini.getBoundingClientRect();
  const mx = (clientX - r.left) * (mini.width  / r.width);
  const my = (clientY - r.top ) * (mini.height / r.height);
  return { x: (mx - cx) / pxPerMeter, z: (my - cy) / pxPerMeter };
}

function drawMinimap(){
  const { W, H, cx, cy, pxPerMeter } = getMiniTransform();

  mctx.clearRect(0,0,W,H);
  mctx.fillStyle = '#0e0e10';
  mctx.fillRect(0,0,W,H);

  mctx.save();
  mctx.translate(cx, cy);

  const h = gridMesh.position.y;
  const rEff = Math.max(0, Math.sqrt(Math.max(SPHERE_RADIUS*SPHERE_RADIUS - h*h, 0)));
  const rPx  = rEff * pxPerMeter;

  const stepPx = Math.max(1, gridMat.uniforms.spacing.value * pxPerMeter);
  const count = Math.floor(rPx / stepPx);

  mctx.strokeStyle = '#1a1f24'; mctx.lineWidth = 1;
  for(let i=-count; i<=count; i++){
    const x = i * stepPx;
    mctx.beginPath(); mctx.moveTo(x, -rPx); mctx.lineTo(x,  rPx); mctx.stroke();
    const z = i * stepPx;
    mctx.beginPath(); mctx.moveTo(-rPx, z); mctx.lineTo( rPx, z); mctx.stroke();
  }

  mctx.strokeStyle = '#ffe28a'; mctx.lineWidth = 2;
  mctx.beginPath(); mctx.moveTo(-rPx,0); mctx.lineTo(rPx,0); mctx.stroke();
  mctx.beginPath(); mctx.moveTo(0,-rPx); mctx.lineTo(0,rPx); mctx.stroke();

  mctx.strokeStyle = '#4ea1ff'; mctx.lineWidth = 2;
  mctx.beginPath(); mctx.arc(0, 0, rPx, 0, Math.PI*2); mctx.stroke();

  mctx.fillStyle = '#ffffff';
  mctx.beginPath(); mctx.arc(0, 0, 3, 0, Math.PI*2); mctx.fill();

  cubes.forEach((c)=>{
    const hx=c.sizes.x*0.5, hy=c.sizes.y*0.5, hz=c.sizes.z*0.5;
    const cornersLocal=[
      new THREE.Vector3(-hx,-hy,-hz),
      new THREE.Vector3( hx,-hy,-hz),
      new THREE.Vector3( hx,-hy, hz),
      new THREE.Vector3(-hx,-hy, hz),
    ];
    const pts = cornersLocal.map(v=>{
      const w=v.clone().applyQuaternion(c.mesh.quaternion).add(c.mesh.position);
      return worldXZToMini(w.x, w.z);
    });

    mctx.fillStyle = c.state.color || '#5a7dff';
    mctx.strokeStyle = (c.id===params.activeId) ? '#ffd400' : '#222';
    mctx.lineWidth = (c.id===params.activeId) ? 3 : 1;

    mctx.beginPath();
    mctx.moveTo(pts[0].x - cx, pts[0].y - cy);
    for(let i=1;i<pts.length;i++) mctx.lineTo(pts[i].x - cx, pts[i].y - cy);
    mctx.closePath();
    mctx.fill(); mctx.stroke();
  });

  mctx.restore();
}

/* ---------- Minimap Interaktion: Klick + Drag (XZ) ---------- */
function pointInPoly(px, py, poly){
  let inside = false;
  for(let i=0, j=poly.length-1; i<poly.length; j=i++){
    const xi=poly[i].x, yi=poly[i].y, xj=poly[j].x, yj=poly[j].y;
    const intersect = ((yi>py)!==(yj>py)) && (px < (xj-xi)*(py-yi)/(yj-yi+1e-9) + xi);
    if (intersect) inside = !inside;
  }
  return inside;
}
function quadForCube2D(c){
  const hx=c.sizes.x*0.5, hy=c.sizes.y*0.5, hz=c.sizes.z*0.5;
  const cornersLocal=[
    new THREE.Vector3(-hx,-hy,-hz),
    new THREE.Vector3( hx,-hy,-hz),
    new THREE.Vector3( hx,-hy, hz),
    new THREE.Vector3(-hx,-hy, hz),
  ];
  const worldPts = cornersLocal.map(v=> v.applyQuaternion(c.mesh.quaternion).add(c.mesh.position));
  return worldPts.map(w => worldXZToMini(w.x, w.z));
}
function moveCubeXZ(c, wx, wz){
  c.mesh.position.x = snap001(wx);
  c.mesh.position.z = snap001(wz);
  updateRaysFor(c.mesh, c.rays, c.sizes);
  c.syncFromMesh();
}
function pickCubeOnMini(clientX, clientY){
  const r = mini.getBoundingClientRect();
  const mx = (clientX - r.left) * (mini.width  / r.width);
  const my = (clientY - r.top ) * (mini.height / r.height);
  for(let i=cubes.length-1; i>=0; i--){
    const c = cubes[i];
    const poly = quadForCube2D(c);
    if (pointInPoly(mx, my, poly)) return c;
  }
  return null;
}
let dragState = null; // { cube, offX, offZ }
mini.addEventListener('pointerdown', (e)=>{
  const cube = pickCubeOnMini(e.clientX, e.clientY);
  if (!cube) return;
  activateCubeById(cube.id);
  const world = miniToWorldXZ(e.clientX, e.clientY);
  dragState = { cube, offX: cube.mesh.position.x - world.x, offZ: cube.mesh.position.z - world.z };
  mini.classList.add('dragging');
});
window.addEventListener('pointermove', (e)=>{
  if (!dragState) return;
  const world = miniToWorldXZ(e.clientX, e.clientY);
  moveCubeXZ(dragState.cube, world.x + dragState.offX, world.z + dragState.offZ);
});
window.addEventListener('pointerup', ()=>{
  if (dragState){
    mini.classList.remove('dragging');
    dragState = null;
  }
});

/* ---------- Scroll auf Minimap: Grid hoch/runter ---------- */
mini.addEventListener('wheel', (e)=>{
  e.preventDefault();
  e.stopPropagation();
  const sensitivity = 0.001;
  const fine = e.shiftKey ? 0.25 : 1.0;
  const deltaMeters = -e.deltaY * sensitivity * fine;
  setGridY(params.gridHeight + deltaMeters);
}, { passive:false });

/* ---------- Kamera-Basis & Info ---------- */
function updateCamBasis(){
  const dir = camera.position.clone().sub(controls.target);
  if (dir.lengthSq() === 0) dir.set(0,0,1);
  dir.normalize().multiplyScalar(CAMERA_RADIUS);
  camera.position.copy(controls.target).add(dir);

  camera.updateMatrixWorld();
  const e = camera.matrixWorld.elements;
  const right = new THREE.Vector3(e[0],e[1],e[2]).normalize();
  const up    = new THREE.Vector3(e[4],e[5],e[6]).normalize();
  const zAxis = new THREE.Vector3(e[8],e[9],e[10]).normalize();
  const m = new THREE.Matrix3();
  m.set(right.x,up.x,zAxis.x, right.y,up.y,zAxis.y, right.z,up.z,zAxis.z);
  passAMat.uniforms.camBasis.value.copy(m);
  passAMat.uniforms.aspect.value = camera.aspect;

  syncCamInfoFromCamera();
}

/* ---------- Reset / Wheel / Resize / Render ---------- */
document.getElementById('resetView').addEventListener('click', ()=>{
  controls.reset();
  renderer.domElement.focus();
  syncCamInfoFromCamera();
});

function applyFovDelta(deltaY){
  const scale = Math.exp(deltaY * -0.001);
  const newFov = THREE.MathUtils.clamp(camera.fov * scale, 40, 140);
  if (newFov !== camera.fov){
    camera.fov = newFov;
    camera.updateProjectionMatrix();
    passAMat.uniforms.fovY.value = THREE.MathUtils.degToRad(newFov);
    params.cameraFov = newFov;
    cameraFovCtrl.updateDisplay();
    fovCtrl.updateDisplay();
  }
}
renderer.domElement.addEventListener('wheel', (e)=>{
  const guiEl = document.querySelector('.lil-gui');
  const uiBar = document.getElementById('ui');
  const within = el => el && el.contains(e.target);
  if (within(guiEl) || within(uiBar)) return;
  e.preventDefault();
  e.stopPropagation();
  applyFovDelta(e.deltaY);
}, { passive:false });

let baseFov = camera.fov;
renderer.domElement.addEventListener('gesturestart', ()=>{ baseFov = camera.fov; }, { passive:true });
renderer.domElement.addEventListener('gesturechange', (e)=>{
  const target = THREE.MathUtils.clamp(baseFov / e.scale, 40, 140);
  camera.fov = target;
  camera.updateProjectionMatrix();
  passAMat.uniforms.fovY.value = THREE.MathUtils.degToRad(target);
  params.cameraFov = target;
  cameraFovCtrl.updateDisplay();
  fovCtrl.updateDisplay();
}, { passive:true });

function resizeAll(){
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();

  passAMat.uniforms.fovY.value = THREE.MathUtils.degToRad(camera.fov);
  passAMat.uniforms.aspect.value = camera.aspect;

  renderer.getDrawingBufferSize(db);
  passAMat.uniforms.resolution.value.copy(db);
  passBMat.uniforms.resolution.value.copy(db);
  rtObjects.setSize(db.x, db.y);
  rtCombined.setSize(db.x, db.y);

  cubes.forEach(c=>{
    const mat = c.edges?.material;
    if (mat && mat.resolution){
      mat.resolution.set(db.x, db.y);
      mat.linewidth = 1.5;
      mat.needsUpdate = true;
    }
  });
}
window.addEventListener('resize', resizeAll);

/* ---------- Renderloop ---------- */
renderer.setClearColor(0x000000, 0);
function render(){
  controls.update();
  updateCamBasis();

  const cur = new THREE.Vector2(); renderer.getDrawingBufferSize(cur);
  if(cur.x !== db.x || cur.y !== db.y){
    db.copy(cur);
    passAMat.uniforms.resolution.value.copy(db);
    passBMat.uniforms.resolution.value.copy(db);
    rtObjects.setSize(db.x, db.y);
    rtCombined.setSize(db.x, db.y);
    cubes.forEach(c=>{
      const mat = c.edges?.material;
      if (mat && mat.resolution){
        mat.resolution.set(db.x, db.y);
        mat.linewidth = 1.5;
        mat.needsUpdate = true;
      }
    });
  }

  gridMat.uniforms.planeY.value = gridMesh.position.y;

  const prev = renderer.getRenderTarget();
  renderer.setRenderTarget(rtObjects);
  renderer.clear(true,true,true);
  renderer.render(sceneObjects, camera);
  renderer.setRenderTarget(prev);

  renderer.setRenderTarget(rtCombined);
  renderer.clear(true,true,true);
  renderer.render(screenSceneA, fsCam);
  renderer.setRenderTarget(null);

  passBMat.uniforms.src.value = rtCombined.texture;
  renderer.render(screenSceneB, fsCam);

  drawMinimap();
  requestAnimationFrame(render);
}
render();

/* ---------- Upload & Spawn ---------- */
document.getElementById('file').addEventListener('change', (e)=>{
  const file = e.target.files?.[0]; if(!file) return;
  const url = URL.createObjectURL(file);
  new THREE.TextureLoader().load(url, (tex)=>{
    tex.colorSpace = THREE.SRGBColorSpace;
    tex.wrapS = THREE.RepeatWrapping;
    tex.wrapT = THREE.ClampToEdgeWrapping;
    panoTex = tex;
    passAMat.uniforms.pano.value = panoTex;
    URL.revokeObjectURL(url);
  });
});
document.getElementById('spawn').addEventListener('click', spawnCube);

/* ---------- Initial GUI Sync ---------- */
syncCamInfoFromCamera();
</script>
</body>
</html>
